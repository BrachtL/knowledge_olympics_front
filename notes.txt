

/*
considerações:

	next steps:
	
	- add password and confirmation password fields to sutedent's login page
	
	- backend: student login 
		receive form data, send jwt and student's name
		jwt should store student or teacher, id, name
	- frontend: make a request with token to verify if user is logged
	when trying to access /question and /teacher-question
	- backend: verify if the token is valid when trying to access
	/question and /teacher-question
	
	DONE: show the student's name on the top, to prevent and detect if someone uses
	the other student's name
	
	
	jwt has to expire 05 minutes after the exam's duration
	

	urls
		root/aluno 		(login do aluno)
		root/professor 	(login do professor)
		root/prova 		(aluno resolve a prova, se não estiver logado redir)
		root/criar 		(professor cria questões, se não estiver logado redir)
		root/ 			(pergunta se é aluno ou prof e redireciona)
		root/controle 	(login para mim)
		
	
	

	como prevenir 2 alunos logarem com o mesmo nome? (fraude)
		- não é possível ter senhas, e ainda que tivesse
		
		DONE: solução: mostrar na tela o nome, turma e numero da chamada do user
		
		solução: detectar de onde vem os dados
		
		- criar uma flag para o usuário que logou,
		então ninguem mais pode logar nesse nome
		- se der problema com o login do usuário e ele tiver que logar de novo
			-> eu derrubo ele da minha plataforma de controle (usando ID)
		
	criar um ambiente de controle para mim
		função: deslogar usuário, para ele poder relogar


	check if all questions have answers when trying to finish the exam
	

*/


/* 
DONE {
	DB

	check if db types of data are appropriate
}
*/

CREATE TABLE students(
	id INT PRIMARY KEY AUTO_INCREMENT,
	name VARCHAR(50) NOT NULL,
	birthdate DATE NOT NULL,
	number INT NOT NULL,
	classroom VARCHAR(20) NOT NULL,
	school VARCHAR(50) NOT NULL,
	score INT	
);

CREATE TABLE teachers(
	id INT PRIMARY KEY AUTO_INCREMENT,
	subject VARCHAR(20) NOT NULL,
	name VARCHAR(50) NOT NULL,
	password CHAR(60) NOT NULL
);

CREATE TABLE questions(
	id INT PRIMARY KEY AUTO_INCREMENT,
	subject VARCHAR(20) NOT NULL,
	id_teacher INT NOT NULL,
	question VARCHAR(1000) NOT NULL,
	correct_answer VARCHAR(500) NOT NULL,
	wrong_answer_1 VARCHAR(500) NOT NULL,
	wrong_answer_2 VARCHAR(500) NOT NULL,
	wrong_answer_3 VARCHAR(500) NOT NULL,
	wrong_answer_4 VARCHAR(500) NOT NULL,
	FOREIGN KEY (id_teacher) REFERENCES teachers(id)
);

CREATE TABLE student_answers(
	id INT PRIMARY KEY AUTO_INCREMENT,
	id_students INT NOT NULL,
	id_questions INT NOT NULL,
	answer CHAR(1) NOT NULL,
	FOREIGN KEY (id_students) REFERENCES students(id),
	FOREIGN KEY (id_questions) REFERENCES questions(id)
);


ALTER TABLE questions
ADD media_type VARCHAR(20) NOT NULL,
ADD media_name VARCHAR(500),
ADD media_url VARCHAR(500),
ADD media_source VARCHAR(500);

ALTER TABLE questions
MODIFY question VARCHAR(2000) NOT NULL;


UPDATE questions SET media_type = 'no';

INSERT INTO teachers (subject, name, password) values ('German', 'Fabiane', '$2a$10$e4aRnvUr3aKdQY3DRtUsjuE6ALcSkvR8TaZeFhQKaKOEKAThiE3rm');
INSERT INTO teachers (subject, name, password) values ('German', 'Gerlinde', '$2a$10$G7MHh/qcPfizsl06pveW6e924/9udUTT0KNcvZzf6WdDrLAShmanm');

INSERT INTO questions (subject, id_teacher, question, correct_answer, wrong_answer_1, wrong_answer_2, wrong_answer_3, wrong_answer_4) values ("German", 2, '', '', '', '', '', '');

INSERT INTO questions (subject, id_teacher, question, correct_answer, wrong_answer_1, wrong_answer_2, wrong_answer_3, wrong_answer_4) values ("German", 3, '', '', '', '', '', '');


 ALTER TABLE students ADD creation_datetime DATETIME NOT NULL;
 
 ALTER TABLE questions ADD media_text VARCHAR(5000);
 
 
 /*
 
 Loading exam page steps
 
	front next commit message:
	
>>>>>>>>>>  delete text var from the login.jsx file  <<<<<<<<<<

	FEATURE: media manipulation in exam page


	DONE: first version: without media manipulation
	(I will send, but not use it in front yet)
	
	DONE: second version: with media manipulation
	
		- audio
		- text
	
	
	DONE {
		Back algorithm:
		
			- create questionsArray
				- shuffle alternatives (options) here
			- create orderedQuestionsArray and mediasArray
			- must to check if media_name != null or '' (or type != no ??)
			- extract the different medias from the questions in an ARRAY
			- I must to add "no" type in the mediasArray
			- create separeted arrays : audio, others
			- shuffle audio and others
			- if id is even, audio will be the first in this ARRAY
			- if id is odd, audio would be the last in this ARRAY
			- loop inside a loop to check if each question matches or not each media
				- create a temp array with the questions that match this media in loop
				//- shuffle this array at the end of the loop
				- join it into the orderedQuestionsArray
			
			- bug in the loop inside a loop to order the questions properly
				
		commit backend
	
		than make the first version in front, commit
	}
	
	DONE: than next version in front, commit
	
	I think it is DONE: - audios are not organized as intented to
	
	*/
	
/*
	deal with image (if needed)
	
	- send id property from backend on each question of questions array
	(- send it back again when send the exam from the frontend)
	commit back again if any changes
*/
		

 


/*

maybe another solution is to send the current cookie and try to match
to the content id is being modified (teachers only). It prevents to have a lot
of modifications and lose everything when trying to save

Solve this multiple login problem!

bug -> when an user logs in another tab, the cookie is update to this new one.
if the previous user (assuming a teacher) updates questions,
the modal says it was good, but it was not.
Actually, it could lead to a bigger problem, which is one teacher overwright
data of another teacher.

I have to:
	- check if the question id matches (belogs to) teacher id,
	if it is not, ask username and password again, if it maches, update
	if it does not match, delete cookie and redirect
	
	or: ask again username and password and see if it matches current cookie
	(best one) --> or: ask again username and password and see if the question ids matches
	
	
	for the student: check if the name in frontend matches with the name
	related to the cookie id, if it does not match, we have a problem (fraud)
	
	say to the supervisor that the student should remain in the same PC
	all the exam. If it has to change, I have to know what student is.

*/

/*

bug -> why the requests are being made twice?
I load a page once and the server receives 2 requests

*/


UPDATE questions
SET media_text = '<p>Es gibt sehr viele verschiedene Berufe.</p><p>Ein <b>Lehrer</b> unterrichtet Schüler und bringt ihnen verschiedene Dinge bei. In einer Volksschule lehren Lehrer den Kindern das Lesen und Schreiben. Lehrer arbeiten auch mit älteren Kindern und Jugendlichen. Dort unterrichten sie meistens ein bestimmtes Fach, Mathematik oder Sprachen zum Beispiel.</p>

<p>Ein anderer Beruf, bei dem man auf der Universität studieren muss: <b>Arzt</b>. Ein Arzt behandelt kranke Leute in einer Praxis oder im Krankenhaus. Er untersucht die Menschen und stellt fest, was ihnen fehlt. Er verschreibt Medikamente oder andere Behandlungen. Es gibt viele verschiedene Ärzte, manche sind Chirurgen, andere sind Ohrenärzte oder Zahnärzte.</p>

<p>Handwerker lernen ihren Beruf in einer Berufsausbildung. Ein Handwerker ist zum Beispiel ein <b>Bäcker</b>. Er stellt Brot her. Dazu muss er wissen, wie man Mehl, Salz, Hefe und andere Zutaten mischt. Bäcker können sehr viele verschiedene Sorten Brot machen, auch süßes Gebäck.</p>

<p>Ein <b>Bauer</b> arbeitet auch mit Lebensmitteln. Auf seinem Hof hält er Tiere wie Kühe, Hühner oder Schweine. Auf den Feldern pflanzt er Getreidesorten oder Gemüse und Obst. Das liefert er an Supermärkte oder verkauft es selbst auf einem Markt.</p>

<p>Ein <b>Koch</b> arbeitet auch mit Lebensmitteln. In einem Restaurant bereitet er die Speisen zu. Seine Ausbildung macht er entweder in einer Schule oder in einer Lehre.</p>

<p>Ein <b>Verkäufer</b> arbeitet in einem Laden. Dort verkauft er an die Kunden, was der Laden bietet: Das können Lebensmittel sein, aber auch Kleidung oder Autos. </p>'
WHERE media_name = 'Berufe';



ALTER TABLE student_answers
MODIFY answer VARCHAR(500);

ALTER TABLE students
ADD are_options_created BOOLEAN DEFAULT FALSE;


















backup queries:

const pool = require('./dbConfig');

async function getExamPageStudentData(studentId) {
  try {
    const connection = await pool.getConnection();
    const [results, fields] = await connection.query(`
      SELECT name, number, classroom, school
      FROM students
      WHERE id = '${studentId}'`);
    connection.release();
    console.log(`getExamPageStudentData(${studentId}) return:`, results[0]);
    return results[0];
  } catch (err) {
    console.log('Error querying database: getExamPageStudentData', err);
    console.log("THE MESSAGE IS:  ->> ", err.sqlMessage, " <<-");
    throw new Error(err.sqlMessage);
  }
}


async function getExamPageQuestionsData(studentId) {
  try {
    const connection = await pool.getConnection();
    const [results, fields] = await connection.query(`
      SELECT
      id, question, correct_answer, wrong_answer_1, wrong_answer_2, 
      wrong_answer_3, wrong_answer_4, media_type, media_name,
      media_url, media_source, media_text
      FROM questions
      WHERE id_teacher = '${2}' OR id_teacher = ${3}`); //todo: remove this ehre cluase from here?
    connection.release();
    console.log(`getExamPageQuestionsData(${studentId}) return:`, results[0]);
    return results;
  } catch (err) {
    console.log('Error querying database: getExamPageQuestionsData', err);
    console.log("THE MESSAGE IS:  ->> ", err.sqlMessage, " <<-");
    throw new Error(err.sqlMessage);
  }
}

async function getTeacherQuestionsPageData(teacherId) {
  try {
    const connection = await pool.getConnection();
    const [results, fields] = await connection.query(`
      SELECT
      teachers.name, teachers.subject,
      questions.id, questions.question, questions.correct_answer, questions.wrong_answer_1,
      questions.wrong_answer_2, questions.wrong_answer_3, questions.wrong_answer_4,
      questions.media_type, questions.media_name, questions.media_url, questions.media_source
      FROM teachers
      JOIN questions ON teachers.id = questions.id_teacher
      WHERE questions.id_teacher = '${teacherId}'`);
    connection.release();
    console.log('getCredentials() return:', results[0]);
    return results;
  } catch (err) {
    console.log('Error querying database: getCredentials', err);
    console.log("THE MESSAGE IS:  ->> ", err.sqlMessage, " <<-");
    throw new Error(err.sqlMessage);
  }
}

//todo: when teacher change media info, url will be wrong
//maybe the best is to send these media info to a "moderator"/"manager"
//and this person send media info to the questions table.
//Until I implement this, it will be as it is now.
async function updateQuestions(teacherId, questionsArray) {
  try {
    const connection = await pool.getConnection();
    for(let k = 0; k < questionsArray.length; k++) {
      const [results, fields] = await connection.query(`
        UPDATE questions SET 
        correct_answer = ?, media_name = ?,
        media_source = ?, media_type = ?,
        question = ?, wrong_answer_1 = ?, 
        wrong_answer_2 = ?, wrong_answer_3 = ?, 
        wrong_answer_4 = ? 
        WHERE id_teacher = ? AND id = ?`,
        [
          questionsArray[k].correct_answer, questionsArray[k].media_name,
          questionsArray[k].media_source, questionsArray[k].media_type,
          questionsArray[k].question, questionsArray[k].wrong_answer_1,
          questionsArray[k].wrong_answer_2, questionsArray[k].wrong_answer_3 ,
          questionsArray[k].wrong_answer_4,
          teacherId, questionsArray[k].id
        ]);
      console.log(`updateQuestions with teacherId = ${teacherId} and questionsArray[${k}] = ${JSON.stringify(questionsArray[k])} return: ${JSON.stringify(results)}`);
    }
    
    connection.release();
    return "success";
  } catch (err) {
    console.log('Error querying database: updateQuestions', err);
    console.log("THE MESSAGE IS:  ->> ", err.sqlMessage, " <<-");
    throw new Error(err.sqlMessage);
  }
}

async function getTeacherUserData(name) {
  //console.log("checkpoint 2");
  try {
    const connection = await pool.getConnection();
    const [results, fields] = await connection.query(`
      SELECT
      id, password
      FROM teachers
      WHERE name = '${name}'`);
    connection.release();
    console.log(`getTeacherUserData(${name}) return:`, results[0]);
    return results[0];
  } catch (err) {
    console.log(`Error querying database: getTeacherUserData(${name})`, err);
    console.log("THE MESSAGE IS:  ->> ", err.sqlMessage, " <<-");
    throw new Error(err.sqlMessage);
  }
}

async function getStudentData(name) {
  //console.log("checkpoint 2");
  try {
    const connection = await pool.getConnection();
    const [results, fields] = await connection.query(`
      SELECT
      id, name, number, classroom, school
      FROM students
      WHERE LOWER(name) = LOWER('${name}')`);
    connection.release();
    console.log(`getStudentData(${name}) return:`, results[0]);
    return results[0];
  } catch (err) {
    console.log(`Error querying database: getStudentData(${name})`, err);
    console.log("THE MESSAGE IS:  ->> ", err.sqlMessage, " <<-");
    throw new Error(err.sqlMessage);
  }
}

async function setStudentData(name, birthdate, numberId, classroom, school) {
  try {
    const connection = await pool.getConnection();

    const [results, fields] = await connection.query(`
      INSERT INTO students (name, birthdate, number, classroom, school, creation_datetime) 
      VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)`,
      [name, birthdate, numberId, classroom, school]);    
    connection.release();

    console.log(`
      INSERT INTO students (name, birthdate, number, classroom, school, creation_datetime) 
      VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)`,
      [name, birthdate, numberId, classroom, school]); 
    console.log('setStudentData() return:', results);
    return results.insertId;
  } catch (err) {
    console.log('Error querying database: setStudentData', err);
    console.log("A MENSAGEM É:  ->> ", err.sqlMessage, " <<-");
    throw new Error(err.sqlMessage);
  }
}




async function insertUser(
  email, hashedPassword, name, age, category, description, locationId,
  imageUrl
  ) {
  try {
    const connection = await pool.getConnection();
    //const [results, fields] = await connection.query(`
    //  INSERT INTO users (id_location, email, name, age, password, description, image_url, category) 
    //  VALUES ('${locationId}', '${email}', '${name}', '${age}', '${hashedPassword}', '${description}', '${imageUrl}', '${category}')`);
    //console.log(`INSERT INTO users (id_location, email, name, age, password, description, image_url, category) 
    //VALUES ('${locationId}', '${email}', '${name}', '${age}', '${hashedPassword}', '${description}', '${imageUrl}', '${category}')`);
   
    //todo: insert current_timestamp (or "Now()") in creation_datetime
    const [results, fields] = await connection.query(`
      INSERT INTO users (id_location, email, name, age, password, description, image_url, category, creation_datetime) 
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)`,
      [locationId, email, name, age, hashedPassword, description, imageUrl, category]);    
    connection.release();

    console.log(`
      INSERT INTO users (id_location, email, name, age, password, description, image_url, category, creation_datetime) 
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)`,
      [locationId, email, name, age, hashedPassword, description, imageUrl, category]);
    console.log('insertUser() return:', results);
    return results.insertId;
  } catch (err) {
    console.log('Error querying database: insertUser', err);
    console.log("A MENSAGEM É:  ->> ", err.sqlMessage, " <<-");
    throw new Error(err.sqlMessage);
  }
}

async function insertLocation(latitude, longitude, uf, city) {
  try {
    const connection = await pool.getConnection();
    const [results, fields] = await connection.query(`
      INSERT INTO locations (latitude, longitude, uf, city) VALUES (?, ?, ?, ?)`,
      [latitude, longitude, uf, city]);
    console.log('insertLocation() return:', results);
    connection.release();
    return results.insertId;
    
  } catch (err) {
    console.log('Error querying database: insertLocation', err);
    console.log("THE MESSAGE IS:  ->> ", err.sqlMessage, " <<-");
    throw new Error(err.sqlMessage);
  }
}

async function getLocationId(city, uf) {
  try {
    const connection = await pool.getConnection();
    const [results, fields] = await connection.query(`
      SELECT id FROM locations WHERE city = '${city}' AND uf = '${uf}'`);
    console.log('getLocationId() return:', results);
    connection.release();
    if (results.length > 0) {
      console.log(results[0].id);
      return results[0].id;
    } else {
      return 0;
    }
    
  } catch (err) {
    console.log('Error querying database: getLocationId', err);
    console.log("THE MESSAGE IS:  ->> ", err.sqlMessage, " <<-");
    throw new Error(err.sqlMessage);
  }
}

//this query is only used to give the user a token. All the rest (getUser(id)) is done with the token
async function getUserData(email) {
  try {
    const connection = await pool.getConnection();
    const [results, fields] = await connection.query(`
      SELECT
      users.id, users.email, users.password,
      locations.latitude, locations.longitude
      FROM users
      JOIN locations ON users.id_location = locations.id
      WHERE email = '${email}'`);
    connection.release();
    console.log('getCredentials() return:', results[0]);
    return results[0];
  } catch (err) {
    console.log('Error querying database: getCredentials', err);
    console.log("THE MESSAGE IS:  ->> ", err.sqlMessage, " <<-");
    throw new Error(err.sqlMessage);
  }
}

async function getUser(id) {
  try {
    const connection = await pool.getConnection();
    const [results, fields] = await connection.query(`
      SELECT id, id_location, email, name, age, password, description, image_url, category
      FROM users WHERE id = '${id}'`);
    connection.release();
    console.log('getUser() return:', results[0]);
    return results[0];
  } catch (err) {
    console.log('Error querying database: getUser', err);
    console.log("THE MESSAGE IS:  ->> ", err.sqlMessage, " <<-");
    throw new Error(err.sqlMessage);
  }
}


async function getPetsExceptMineLikedDisliked(userId) {
  try {
    const connection = await pool.getConnection();
/*
    const [results, fields] = await connection.query(`
      SELECT pets.id, pets.id_user, pets.id_location, pets.main_image_URL, pets.name, pets.birthday,
      pets.species, pets.breed, pets.gender, pets.description, pets.creation_datetime,
      locations.country, locations.uf, locations.city, locations.latitude, locations.longitude
      FROM pets
      JOIN locations ON pets.id_location = locations.id
      WHERE pets.id_user != ?`, [userId]);
*/

    const [results, fields] = await connection.query(`SELECT pets.id, pets.id_user, pets.id_location, pets.main_image_URL, pets.name, pets.birthday,
      pets.species, pets.breed, pets.gender, pets.description, pets.creation_datetime,
      locations.country, locations.uf, locations.city, locations.latitude, locations.longitude
      FROM pets
      JOIN locations ON pets.id_location = locations.id
      WHERE pets.id_user != ? 
      AND pets.id NOT IN (
        SELECT id_pet_liked
        FROM user_liked_interactions
        WHERE id_user = ?
      )
      AND pets.id NOT IN (
        SELECT id_pet_disliked
        FROM user_disliked_interactions
        WHERE id_user = ?
      );`, [userId, userId, userId]);


    connection.release();
    console.log(`getPetsExceptMineLikedDisliked(${userId}) return: ${JSON.stringify(results)}`);
    return results;
  } catch (err) {
    console.log('Error querying database: getPetsExceptMineLikedDisliked', err);
    console.log("THE MESSAGE IS:  ->> ", err.sqlMessage, " <<-");
    throw new Error(err.sqlMessage);
  }
}

  async function setLikeRelation(userId, petId) {
    try {
      const connection = await pool.getConnection();
      const [results, fields] = await connection.query(`
        INSERT INTO user_liked_interactions (id_user, id_pet_liked) VALUES (?, ?)`,
        [userId, petId]);
      connection.release();
      console.log(`setLikeRelation(${userId}, ${petId}) return: ${JSON.stringify(results)}`);
      return results.insertId;
    } catch (err) {
      console.log('Error querying database: setLikeRelation', err);
      console.log("THE MESSAGE IS:  ->> ", err.sqlMessage, " <<-");
      throw new Error(err.sqlMessage);
    }
  }

  async function setDislikeRelation(userId, petId) {
    try {
      const connection = await pool.getConnection();
      const [results, fields] = await connection.query(`
        INSERT INTO user_disliked_interactions (id_user, id_pet_disliked) VALUES (?, ?)`,
        [userId, petId]);
      connection.release();
      console.log(`setDislikeRelation(${userId}, ${petId}) return: ${JSON.stringify(results)}`);
      return results.insertId;
    } catch (err) {
      console.log('Error querying database: setDislikeRelation', err);
      console.log("THE MESSAGE IS:  ->> ", err.sqlMessage, " <<-");
      throw new Error(err.sqlMessage);
    }
  }

  async function getSecondaryImagesURL(petId) {
    try {
      const connection = await pool.getConnection();
      const [results, fields] = await connection.query(`
        SELECT url FROM secondary_images_url WHERE id_pet = ?`,
        [petId]);
      connection.release();
      console.log(`getSecondaryImagesURL(${petId}) return: ${JSON.stringify(results)}`);
      
      let urlList = [];
      results.forEach( element => {
        urlList.push(element.url);
      })
      
      console.log(`urlList: ${urlList}`);
      
      return urlList;
    } catch (err) {
      console.log('Error querying database: getSecondaryImagesURL', err);
      console.log("THE MESSAGE IS:  ->> ", err.sqlMessage, " <<-");
      throw new Error(err.sqlMessage);
    }
  }

  //CHECK THIS QUERY!
  async function getLikedPets(userId) {
    try {
      const connection = await pool.getConnection();
  
      const [results, fields] = await connection.query(`SELECT pets.id, pets.id_user, pets.id_location, pets.main_image_URL, pets.name, pets.birthday,
        pets.species, pets.breed, pets.gender, pets.description, pets.creation_datetime,
        locations.country, locations.uf, locations.city, locations.latitude, locations.longitude
        FROM pets
        JOIN locations ON pets.id_location = locations.id
        JOIN user_liked_interactions ON pets.id = user_liked_interactions.id_pet_liked
        WHERE user_liked_interactions.id_user = ?;`, [userId]);
  
  
      connection.release();
      console.log(`getLikedPets(${userId}) return: ${JSON.stringify(results)}`);
      return results;
    } catch (err) {
      console.log('Error querying database: getLikedPets', err);
      console.log("THE MESSAGE IS:  ->> ", err.sqlMessage, " <<-");
      throw new Error(err.sqlMessage);
    }
  }


module.exports = {
  insertUser,
  getUserData,
  getLocationId,
  insertLocation,
  getPetsExceptMineLikedDisliked,
  setLikeRelation,
  setDislikeRelation,
  getSecondaryImagesURL,
  getLikedPets,
  
  getStudentData,
  getTeacherQuestionsPageData,
  getTeacherUserData,
  updateQuestions,
  setStudentData,
  getExamPageQuestionsData,
  getExamPageStudentData
}















backup examController

//const bcrypt = require('bcrypt');
//const jwt = require('jsonwebtoken');
//const { jwtSecret } = require('../configPar');
const { getPetsExceptMineLikedDisliked, setLikeRelation, setDislikeRelation, getSecondaryImagesURL,
  getLikedPets, getTeacherData, getTeacherQuestionsPageData, updateQuestions, getExamPageQuestionsData,
  getExamPageStudentData } = require('../Database/queries');

module.exports.exam_post = async (req, res) => {

}

module.exports.answer_post = async (req, res) => {

}

//todo: use req.decodedToken.type to check if it is a teacher, if it is not -> deny access
//todo: use this type in every get and post request here
module.exports.questions_get = async (req, res) => {
  try {
    const userId = req.decodedToken.id;
    const data = await getTeacherQuestionsPageData(userId);
    console.log(data[0]);
    console.log(`data length = ${data.length}`);

    var questionsArray = [];
    
    for (let k = 0; k < data.length; k++) {
      const questionObject = {}; // Create an object for each question
      questionObject.id = data[k].id;
      questionObject.question = data[k].question;
      questionObject.correct_answer = data[k].correct_answer;
      questionObject.wrong_answer_1 = data[k].wrong_answer_1;
      questionObject.wrong_answer_2 = data[k].wrong_answer_2;
      questionObject.wrong_answer_3 = data[k].wrong_answer_3;
      questionObject.wrong_answer_4 = data[k].wrong_answer_4;
      questionObject.number = k+1;
      questionObject.media_type = data[k].media_type == null || data[k].media_type == "null" ? "" : data[k].media_type;
      questionObject.media_name = data[k].media_name == null || data[k].media_name == "null" ? "" : data[k].media_name;
      questionObject.media_url = data[k].media_url == null || data[k].media_url == "null" ? "" : data[k].media_url;
      questionObject.media_source = data[k].media_source == null ||data[k]. media_source == "null" ? "" : data[k].media_source;
      questionsArray.push(questionObject); // Add the question object to the array
    }

    const questionsPageData = {
      teacherName: data[0].name,
      subject: data[0].subject, // considering each teacher has just one subject
      questionsArray: questionsArray
    }

    res.status(200).json(questionsPageData);   

  } catch(e) {
    console.log(e.toString());
    res.status(400).json({message: e.toString()});
  }
}


//todo: I will use the for loop there probably
module.exports.exam_get = async (req, res) => {
  try {
    const userId = req.decodedToken.id;
    
    const studentData = await getExamPageStudentData(userId);
    const questionsData = await getExamPageQuestionsData(userId);
  

    console.log(`studentData = ${JSON.stringify(studentData)}`);
    //console.log(`studentData length = ${studentData.length}`);

    console.log(`questionsData = ${JSON.stringify(questionsData)}`);
    console.log(`questionsData length = ${questionsData.length}`);

    var questionsArray = [];
    var orderedQuestionsArray = [];
    var mediasArray = [];


    var mediaOtherArray = [];
    var mediaAudioArray = [];
    
    
    for (let k = 0; k < questionsData.length; k++) {
      const questionObject = {}; // Create an object for each question
      questionObject.questionText = questionsData[k].question;
      questionObject.options = shuffleArray([
        questionsData[k].correct_answer, questionsData[k].wrong_answer_1, questionsData[k].wrong_answer_2,
        questionsData[k].wrong_answer_3, questionsData[k].wrong_answer_4
      ]);

      questionObject.id = questionsData[k].id;

      questionObject.media_type = questionsData[k].media_type;
      questionObject.media_name = questionsData[k].media_name;
      questionObject.media_text = questionsData[k].media_text;
      questionObject.media_url = questionsData[k].media_url;
      console.log(`code 00001: `, questionObject.media_type, questionObject.media_name);
      //todo: add what more is needed

      if(questionObject.media_type != "no") {
        //todo: I have to assure that front check media_name length 3 or more
        //before send to api to send to DB
        if(questionObject.media_type == "audio") {
          if (!mediaAudioArray.some(media => media.media_name == questionObject.media_name)) {
            mediaAudioArray.push({
              media_name: questionObject.media_name,
              media_type: questionObject.media_type    
            });
          } 
        } else {
          if (!mediaOtherArray.some(media => media.media_name == questionObject.media_name)) {
            mediaOtherArray.push({
              media_name: questionObject.media_name,
              media_type: questionObject.media_type    
            });
          }
        }
      } else {
        questionObject.media_name = '';
        if(!mediaOtherArray.some(media => media.media_type == "no")) {
          mediaOtherArray.push({
            media_name: '',
            media_type: "no"
          });
        }
      }
      
      //questionObject.number = k+1; //todo: use index in front
      questionsArray.push(questionObject);
    }

    //even starts with Audio
    mediaAudioArray = shuffleArray(mediaAudioArray);
    mediaOtherArray = shuffleArray(mediaOtherArray);
    if((userId % 2) == 0) {
      for(let k = 0; k < mediaAudioArray.length; k++) {
        mediasArray.push(mediaAudioArray[k]);
      }

      for(let k = 0; k < mediaOtherArray.length; k++) {
        mediasArray.push(mediaOtherArray[k]);
      }
      
      //mediasArray.push(mediaAudioArray);
      //mediasArray.push(mediaOtherArray);
    } else {
      for(let k = 0; k < mediaOtherArray.length; k++) {
        mediasArray.push(mediaOtherArray[k]);
      }

      for(let k = 0; k < mediaAudioArray.length; k++) {
        mediasArray.push(mediaAudioArray[k]);
      }


      //mediasArray.push(mediaOtherArray);
      //mediasArray.push(mediaAudioArray);
    }

    console.log(`code 00002: mediasArray: `, JSON.stringify(mediasArray));

    questionsArray = shuffleArray(questionsArray); 
    
    console.log(`code 00003: questionsArray: `, JSON.stringify(questionsArray));
    
    //let i = 0;

    for(let k = 0; k < mediasArray.length; k++) {

      let isFirstMedia = true;

      for(let i = 0; i < questionsArray.length; i++) {
        if(questionsArray[i].media_name == mediasArray[k].media_name) {
          questionsArray[i].number = orderedQuestionsArray.length + 1;
          questionsArray[i].isFirstMedia = isFirstMedia;
          isFirstMedia = false;
          orderedQuestionsArray.push(questionsArray[i]);
          console.log(`k = ${k} and i = ${i}`);
          console.log(`media_name: ${questionsArray[i].media_name}`);
          console.log(`media_type questionsArray: ${questionsArray[i].media_type}`);
          console.log(`media_type orderedQuestionsArray: ${JSON.stringify(orderedQuestionsArray)}`);
          questionsArray.splice(i,1);
          i--;
          //continue;
        }
        //i++;
      }
      //i = 0;
    }

    const questionsPageData = {
      studentName: studentData.name,
      classroom: studentData.classroom,
      numberId: studentData.number,
      school: studentData.school,
      questionsArray: orderedQuestionsArray
    }

    console.log(JSON.stringify(questionsPageData));

    res.status(200).json(questionsPageData);   

  } catch(e) {
    console.log(e.toString());
    res.status(400).json({message: e.toString()});
  }
}

module.exports.questions_post = async (req, res) => {
  try {
    const userId = req.decodedToken.id;

    const message = await updateQuestions(userId, req.body);

    res.status(200).json({
      message: message
    });

  } catch(e) {

    //res.status(400).json({});
    res.status(400).json({message: e.toString()});
  }
}




module.exports.pets_get = async (req, res) => {

  try {
    const userId = req.decodedToken.id;
    const petsList = await getPetsExceptMineLikedDisliked(userId);
    console.log(petsList[0]);
    console.log(`petsList length = ${petsList.length}`);
    
    await getUrlsAndFormatBirthday(petsList);
    console.log("after forEach: ", petsList[10]);
    console.log(`after forEach: petsList length = ${petsList.length}`);

    res.status(200).json({
      petsList: petsList
    });   

  } catch(e) {

    //res.status(400).json({});
    res.status(400).json({message: e.toString()});
  }

}

//todo: use try catch here is probably a good idea
async function getUrlsAndFormatBirthday(petsList) {
  const promises = petsList.map(async (element) => {
    element.secondary_images_URL = await getSecondaryImagesURL(element.id);

    const date = new Date(element.birthday);
    const formattedDate = date.toLocaleDateString("en-GB", {
      day: "2-digit",
      month: "2-digit",
      year: "numeric",
    });
    //element.birthday = formattedDate.replace(/-/g, "/");
    element.birthday = formattedDate;
    return element;
  });

  // Wait for all promises to resolve
  return Promise.all(promises);
}


//todo: implement this function
module.exports.like_pet_post = async (req, res) => {

  try {
    const userId = req.decodedToken.id;
    const petId = req.body.petId;
    console.log(`LIKE petId -> ${petId}`);

    const insertId = await setLikeRelation(userId, petId);

    res.status(200).json({
      message: "Success"
    });

  } catch(e) {

    //res.status(400).json({});
    res.status(400).json({message: e.toString()});
  }
}

module.exports.dislike_pet_post = async (req, res) => {

  try {
    const userId = req.decodedToken.id;
    const petId = req.body.petId;
    console.log(`DISLIKE petId -> ${petId}`);

    const insertId = await setDislikeRelation(userId, petId);

    res.status(200).json({
      message: "Success"
    });

  } catch(e) {

    //res.status(400).json({});
    res.status(400).json({message: e.toString()});
  }
}


module.exports.pets_grid_get = async (req, res) => {

  try {
    const userId = req.decodedToken.id;
    const petsLikedList = await getLikedPets(userId);
    console.log(petsLikedList[0]);
    console.log(`petsLikedList length = ${petsLikedList.length}`);
    
    await getUrlsAndFormatBirthday(petsLikedList);
    console.log("after forEach: ", petsLikedList[0]);
    console.log(`after forEach: petsLikedList length = ${petsLikedList.length}`);

    res.status(200).json({
      petsList: petsLikedList
    });   

  } catch(e) {

    //res.status(400).json({});
    res.status(400).json({message: e.toString()});
  }


}

  function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  }




/*

NEXT STEPS (security/login/fraud)

		DONE: - prevent teacher to log in when there is cookie saved
		(like I already did in student login page)

		DONE: - match the type alongsige with id, since there are duplicated ids
		between types

	- every 5 seconds check if the cookie's id is the same the id
	I have in the frontend pagedata: send both to API and check if it matches
		create a resource for it (/checkLogin POST)
	
		DONE: - on the function I already have to save questions -> execute the
		same function checkLogin executes to match frontend data with cookie data
	
		DONE: FOR BOTH cases above: define a message "match fail"
		DONE: in frontend -> when the message is "match fail", erase cookie and reload page
	
	
		DONE: - when there is cookie, redirect from any login page to the proper page
		which are questions if student or create-questions if teacher
	
	
	- I need still to show modal message and redirect (login page when there
	is cookie)
	(instead of a modal, I can show the message in login page, using context)
	
	
		DONE: - use matchCookie thing on teacher question-creation as well
	- when save and every 5 seconds
	
	
		
	FRONT COMMIT MESSAGE:
		FEATURE: prevent teacher login if there is jwt cookie; match cookie interval 5 seconds
			DONE:
			FEATURE: prevent login when there is a jwt cookie; if id and tyoe sent
			through body doest not match those on jwt header, erase cookie
			and refresh page; fix redirecting always sending to student login page
			
		
	BACK COMMIT MESSAGE:
			
			DONE:
			FEATURE: userId is now sent with user's data, matchCookie
			
		

*/

